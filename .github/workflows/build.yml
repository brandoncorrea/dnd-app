name: Run Build

on:
  push:
    branches:
      - master
      - stage
      - production

jobs:
#  test:
#    runs-on: ubuntu-latest
#
#    steps:
#      - uses: actions/checkout@v4
#      - uses: brandoncorrea/clojure-base@v1
#
#      - name: Run ClojureScript Tests
#        run: ME_ENV=ci clojure -M:test:cljs once
#
#      - name: Run Clojure Tests
#        run: clojure -M:test:spec

  deploy:
    runs-on: ubuntu-latest
#    needs: test
    if: contains('stage production', github.ref_name)
    environment: ${{ github.ref_name }}

    concurrency:
      group: deploy-ec2-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - uses: brandoncorrea/ec2-mono@master
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          aws-image-id: ami-04a81a99f5ec58529
          aws-instance-type: t2.small
          aws-security-group-ids: ${{ secrets.SECURITY_GROUP_IDS }}
          aws-key-name: ${{ secrets.SSH_PRIVATE_KEY_NAME }}
          app-name: ${{ vars.APP_NAME }}
          env-name: ${{ vars.ME_ENV }}

      - name: Get Public IP
        run: |
          EC2_PUBLIC_IP=$(aws ec2 describe-instances --instance-ids ${{ env.EC2_NEW_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          EC2_FINGERPRINT=$(ssh-keyscan -H $PUBLIC_IP)
          echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV
          echo "EC2_FINGERPRINT=$EC2_FINGERPRINT" >> $GITHUB_ENV

      - name: Install Service
        uses: D3rHase/ssh-command-action@v0.2.2
        with:
          host: ${{ env.EC2_PUBLIC_IP }}
          user: ${{ secrets.SSH_USER }}
          private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          host_fingerprint: ${{ env.EC2_FINGERPRINT }}
          command: |
            git clone "${{ github.server_url }}/${{ github.repository }}" ${{ vars.APP_NAME }}
            cd ${{ vars.APP_NAME }}

            ./bin/prep
            ./bin/install-java
            ./bin/install-clojure

            echo "Installing SSL"
            sudo echo "${{ secrets.SSL_CERTIFICATE }}" | sudo tee -a /etc/ssl/bwawan.com.crt > /dev/null
            sudo echo "${{ secrets.SSL_PRIVATE_KEY }}" | sudo tee -a /etc/ssl/bwawan.com.key > /dev/null

            echo "Installing Secrets"
            echo "ME_ENV=${{ vars.ME_ENV }}" >> .env
            echo "DOMAIN=${{ vars.DOMAIN }}" >> .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env

            clojure -M:test:cljs once
            clojure -M:test:css once

            ./bin/install-service ${{ vars.ME_ENV }}
            ./bin/install-nginx ${{ vars.DOMAIN }}

      - name: Wait for instance to be ready
        uses: iFaxity/wait-on-action@v1.2.1
        with:
          resource: https://${{ env.EC2_PUBLIC_IP }}
          interval: 1000
          timeout: 600000

      - name: Allocate Elastic IP Address
        run: |
          ALLOCATION_ID=$(aws ec2 describe-addresses \
            --filters "Name=tag:app,Values=${{ vars.APP_NAME }}" "Name=tag:env,Values=${{ vars.ME_ENV }}" \
            --query 'Addresses[0].AllocationId' \
            --output text)
          aws ec2 associate-address --instance-id ${{ env.EC2_NEW_INSTANCE_ID }} --allocation-id $ALLOCATION_ID

      - name: Delete old instances if they exist
        if: env.EC2_OLD_INSTANCE_IDS != ''
        run: aws ec2 terminate-instances --instance-ids ${{ env.EC2_OLD_INSTANCE_IDS }}

      - name: Cleanup new instance if job fails
        if: failure() && env.EC2_NEW_INSTANCE_ID != ''
        run: aws ec2 terminate-instances --instance-ids ${{ env.EC2_NEW_INSTANCE_ID }}
