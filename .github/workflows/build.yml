name: Run Build

on:
  push:
    branches:
      - master
      - stage
      - production

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: brandoncorrea/clojure-base@v1

      - name: Run ClojureScript Tests
        run: ME_ENV=ci clojure -M:test:cljs once

      - name: Run Clojure Tests
        run: clojure -M:test:spec

  deploy:
    runs-on: ubuntu-latest
    needs: test
    if: contains('stage production', github.ref_name)
    environment: ${{ github.ref_name }}

    concurrency:
      group: deploy-ec2-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - uses: brandoncorrea/ec2-mono@master
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          aws-image-id: ami-04a81a99f5ec58529
          aws-instance-type: t2.small
          aws-security-group-ids: ${{ secrets.SECURITY_GROUP_IDS }}
          aws-key-name: ${{ secrets.SSH_PRIVATE_KEY_NAME }}
          app-name: ${{ vars.APP_NAME }}
          env-name: ${{ vars.ME_ENV }}

      - name: Set up SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Prep SSH
        run: |
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids ${{ env.EC2_NEW_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          ssh-keyscan -H $PUBLIC_IP >> ~/.ssh/known_hosts

      - name: Install Service
        run: |
          ssh -T ${{ secrets.SSH_USER }}@${{ env.PUBLIC_IP }} << 'EOF'
            git clone "${{ github.server_url }}/${{ github.repository }}" ${{ vars.APP_NAME }}
            cd ${{ vars.APP_NAME }}

            ./bin/prep
            ./bin/install-java
            ./bin/install-clojure

            echo "Installing SSL"
            sudo echo "${{ secrets.SSL_CERTIFICATE }}" | sudo tee -a /etc/ssl/bwawan.com.crt > /dev/null
            sudo echo "${{ secrets.SSL_PRIVATE_KEY }}" | sudo tee -a /etc/ssl/bwawan.com.key > /dev/null

            echo "Installing Secrets"
            echo "ME_ENV=${{ vars.ME_ENV }}" >> .env
            echo "DOMAIN=${{ vars.DOMAIN }}" >> .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env

            clojure -M:test:cljs once
            clojure -M:test:css once

            ./bin/install-service ${{ vars.ME_ENV }}
            ./bin/install-nginx ${{ vars.DOMAIN }}
          EOF

      - name: Wait for instance to be ready
        run: |
          MAX_WAIT_TIME=600
          SLEEP_TIME=1
          WAIT_TIME=0
          until curl --insecure -s -o /dev/null -w "%{http_code}" https://${{ env.PUBLIC_IP }} | grep -q "200"; do
            WAIT_TIME=$((WAIT_TIME + SLEEP_TIME))
            if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
              echo "Timed out waiting for instance to be ready."
              exit 1
            fi
            echo "Waiting for instance to be ready..."
            sleep $SLEEP_TIME
          done
          echo "Instance is ready."

      - name: Allocate Elastic IP Address
        run: |
          ALLOCATION_ID=$(aws ec2 describe-addresses \
            --filters "Name=tag:app,Values=${{ vars.APP_NAME }}" "Name=tag:env,Values=${{ vars.ME_ENV }}" \
            --query 'Addresses[0].AllocationId' \
            --output text)
          aws ec2 associate-address --instance-id ${{ env.EC2_NEW_INSTANCE_ID }} --allocation-id $ALLOCATION_ID

      - name: Delete old instances if they exist
        if: env.EC2_OLD_INSTANCE_IDS != ''
        run: aws ec2 terminate-instances --instance-ids ${{ env.EC2_OLD_INSTANCE_IDS }}

      - name: Cleanup new instance if job fails
        if: failure() && env.EC2_NEW_INSTANCE_ID != ''
        run: aws ec2 terminate-instances --instance-ids ${{ env.EC2_NEW_INSTANCE_ID }}
